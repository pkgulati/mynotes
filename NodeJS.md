### require
require will treat internal modules and user modules differently.
For Native module NativeModule.require will get invoked, which internally will call NativeModule.compile
For User Modules and Module.prototype.load will get called (after create of new Module)
Module.load will call extension handlers based on extension, like for .js file 

### .js extension handler
Following method is called to load user module js file
```
Module._extensions['.js'] = function(module, filename) {
  var content = fs.readFileSync(filename, 'utf8');
  module._compile(stripBOM(content), filename);
};
```
### Module._compile
This is called by js extension handler 

### lib/internal/modules/cjs/loader.js
This file has methods like Module._compile,

### NativeModule
NativeModule is internal/bootstrap/loaders.js

### bootstrap/loaders
file name lib/internal/bootstrap/loaders.js
inputs process, getBinding, getLinkedBinding, getInternalBinding, debugBreak

### Internal JavaScript module loader:
NativeModule: a minimal module system used to load the JavaScript core modules found in lib/**/*.js and deps/**/*.js. All core modules are
compiled into the node binary via node_javascript.cc generated by js2c.py, so they can be loaded faster without the cost of I/O. This class makes the lib/internal/*, deps/internal/* modules and internalBinding() available by default to core modules, and lets the core modules require itself via require('internal/bootstrap/loaders') even when this file is not written in CommonJS style.

## General
Before node.js file is run, lib/internal/bootstrap/loaders.js gets run first to bootstrap the internal binding and module loaders, including process.binding(), process._linkedBinding(), internalBinding() and NativeModule. 
And then { internalBinding, NativeModule } will be passed into this bootstrapper to bootstrap Node.js core.

## Internal JS to C example 
process.binding is used to invoke C method from JS
For example fs.readSync method invokes readSync in lib/fs.js which in turn will call
```
const result = binding.read(fd, buffer, offset, length, position,
                              undefined, ctx);
```  
Where binding is 
```
const binding = process.binding('fs');
```
Similarl to fs we have internal modules like
```
process.binding('v8');
process.binding('util')
process.binding('http2')
process.binding('contextify');
process.binding('constants')
process.binding('crypto')
process.binding('http_parser')
process.binding('tcp_wrap')
process.binding('config')
process.binding('trace_events')
```

### Inside C code Internal modules
Internal modules are registered using NODE_BUILTIN_MODULE_CONTEXT_AWARE macro 
For example in fs module is registered in node_file.cc 
NODE_BUILTIN_MODULE_CONTEXT_AWARE(fs, node::fs::Initialize)




